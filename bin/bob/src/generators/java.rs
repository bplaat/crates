/*
 * Copyright (c) 2025 Bastiaan van der Plaat
 *
 * SPDX-License-Identifier: MIT
 */

use std::collections::HashMap;
use std::io::Write;
use std::path::Path;

use indexmap::IndexMap;

use crate::Manifest;

pub(crate) fn generate_ninja(
    f: &mut impl Write,
    manifest_dir: &str,
    manifest: &Manifest,
    source_files: &[String],
) {
    let source_dir = format!("{}/src", manifest_dir);
    let jar_metadata = manifest
        .package
        .metadata
        .as_ref()
        .expect("Missing jar metadata")
        .jar
        .as_ref()
        .expect("Missing jar metadata");

    // Index modules and module dependencies
    let modules = find_modules(source_files);
    let mut deps = HashMap::new();
    for (module, files) in &modules {
        for file in files {
            let source_file = format!("{}/{}", source_dir, file);
            let contents = std::fs::read_to_string(&source_file)
                .unwrap_or_else(|_| panic!("Can't read file: {}", source_file));
            for other_module in modules.keys() {
                let re = regex::Regex::new(&format!(
                    r"import {}.[A-Za-z0-9]+;",
                    other_module.replace("/", ".")
                ))
                .expect("Failed to compile regex");
                if re.is_match(&contents) {
                    deps.entry(module.clone())
                        .or_insert_with(Vec::new)
                        .push(other_module.clone());
                }
            }
        }
    }

    // Variables
    _ = writeln!(f, "# This file is generated by bob, do not edit!\n");

    _ = writeln!(f, "# Variables");
    _ = writeln!(f, "name = {}", manifest.package.name);
    _ = writeln!(f, "version = {}", manifest.package.version);
    _ = writeln!(f, "main_class = {}\n", jar_metadata.main_class);

    _ = writeln!(f, "manifest_dir = ..");
    _ = writeln!(f, "source_dir = $manifest_dir/src");
    _ = writeln!(f, "target_dir = $manifest_dir/target");
    _ = writeln!(f, "classes_dir = $target_dir/classes\n");

    // Rules
    _ = writeln!(f, "# Rules");
    _ = writeln!(
        f,
        "rule javac\n  command = javac -Xlint -cp $classes_dir $in -d $classes_dir && touch $stamp\n  description = javac $in\n"
    );
    _ = writeln!(
        f,
        "rule jar\n  command = jar cfe $out $main_class -C $in .\n  description = jar $out\n"
    );

    // Build modules
    _ = writeln!(f, "# Build modules");
    for (module, source_files) in &modules {
        _ = write!(
            f,
            "build $classes_dir/{}/.stamp: javac {}",
            module,
            source_files
                .iter()
                .map(|source_file| format!("$source_dir/{}", source_file))
                .collect::<Vec<_>>()
                .join(" ")
        );
        if let Some(dependencies) = deps.get(module) {
            _ = write!(
                f,
                " | {}",
                dependencies
                    .iter()
                    .map(|source_file| format!("$classes_dir/{}/.stamp", source_file))
                    .collect::<Vec<_>>()
                    .join(" ")
            );
        }
        _ = writeln!(f, "\n  stamp = $classes_dir/{}/.stamp", module);
    }

    // Build jar
    _ = writeln!(f, "\n# Link jar");
    _ = writeln!(
        f,
        "build $classes_dir: phony {}",
        modules
            .keys()
            .map(|module| format!("$classes_dir/{}/.stamp", module))
            .collect::<Vec<_>>()
            .join(" ")
    );
    _ = writeln!(
        f,
        "build $target_dir/${{name}}-$version.jar: jar $classes_dir",
    );
    _ = writeln!(f, "default $target_dir/${{name}}-$version.jar");
}

pub(crate) fn run(manifest_dir: &str, manifest: &Manifest) {
    let status = std::process::Command::new("java")
        .arg("-jar")
        .arg(format!(
            "{}/target/{}-{}.jar",
            manifest_dir, manifest.package.name, manifest.package.version
        ))
        .status()
        .expect("Failed to execute java");
    if !status.success() {
        std::process::exit(status.code().unwrap_or(1));
    }
}

fn find_modules(source_files: &[String]) -> IndexMap<String, Vec<String>> {
    let mut modules = IndexMap::new();
    for file in source_files {
        if let Some(parent) = Path::new(file).parent() {
            if let Some(parent_str) = parent.to_str() {
                modules
                    .entry(parent_str.to_string())
                    .or_insert_with(Vec::new)
                    .push(file.clone());
            }
        }
    }
    modules
}
