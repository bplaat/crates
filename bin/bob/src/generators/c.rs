/*
 * Copyright (c) 2025 Bastiaan van der Plaat
 *
 * SPDX-License-Identifier: MIT
 */

use std::io::Write;

use crate::Manifest;

pub(crate) fn generate_ninja(
    f: &mut impl Write,
    _manifest_dir: &str,
    manifest: &Manifest,
    source_files: &[String],
) {
    // Filter c source files
    let c_source_files = source_files
        .iter()
        .filter(|source_file| source_file.ends_with(".c"))
        .cloned()
        .collect::<Vec<String>>();

    // Variables
    _ = writeln!(f, "# This file is generated by bob, do not edit!\n");

    _ = writeln!(f, "# Variables");
    _ = writeln!(f, "name = {}", manifest.package.name);
    _ = writeln!(f, "version = {}\n", manifest.package.version);
    _ = writeln!(f, "manifest_dir = ..");
    _ = writeln!(f, "source_dir = $manifest_dir/src");
    _ = writeln!(f, "target_dir = $manifest_dir/target");
    _ = writeln!(f, "objects_dir = $target_dir/objects\n");
    _ = writeln!(f, "cc = gcc");
    _ = writeln!(f, "cflags = -Wall -Wextra -Wpedantic -Werror --std=c11");
    _ = writeln!(f, "ldflags =\n");

    // Rules
    _ = writeln!(f, "# Rules");
    _ = writeln!(
        f,
        "rule cc\n  command = $cc -c $cflags -MD -MF $out.d $in -o $out\n  depfile = $out.d\n  description = cc $in\n"
    );
    _ = writeln!(
        f,
        "rule ld\n  command = $cc $ldflags $in -o $out\n  description = ld $out\n"
    );

    // Build objects
    _ = writeln!(f, "# Build objects");
    for source_file in &c_source_files {
        _ = writeln!(
            f,
            "build $objects_dir/{}: cc $source_dir/{}",
            source_file.replace(".c", ".o"),
            source_file
        );
    }

    // Link executable
    _ = writeln!(f, "\n# Link executable");
    #[cfg(windows)]
    let executable = "$target_dir/${name}-$version.exe";
    #[cfg(not(windows))]
    let executable = "$target_dir/${name}-$version";
    _ = writeln!(
        f,
        "build {}: ld {}",
        executable,
        c_source_files
            .iter()
            .map(|source_file| { format!("$objects_dir/{}", source_file.replace(".c", ".o")) })
            .collect::<Vec<String>>()
            .join(" ")
    );
    _ = writeln!(f, "default {}", executable);
}

pub(crate) fn run(manifest_dir: &str, manifest: &Manifest) {
    let status = std::process::Command::new(
        #[cfg(windows)]
        format!(
            "{}/target/{}-{}.exe",
            manifest_dir, manifest.package.name, manifest.package.version
        ),
        #[cfg(not(windows))]
        format!(
            "{}/target/{}-{}",
            manifest_dir, manifest.package.name, manifest.package.version
        ),
    )
    .status()
    .expect("Failed to execute executable");
    if !status.success() {
        std::process::exit(status.code().unwrap_or(1));
    }
}
