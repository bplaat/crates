/*
 * Copyright (c) 2025 Bastiaan van der Plaat
 *
 * SPDX-License-Identifier: MIT
 */

#![doc = include_str!("../README.md")]
#![forbid(unsafe_code)]

use std::fs;
use std::io::Write;
use std::process::{Command, exit};

use args::Profile;
use rules::Rule;
use utils::{create_file_and_parent_dirs, format_bytes, index_files};

use crate::args::{Args, Subcommand, parse_args};
use crate::manifest::Manifest;

mod args;
mod manifest;
mod rules;
mod utils;

// MARK: Subcommands
fn subcommand_clean(args: &Args) {
    let target_dir = format!("{}/target", args.manifest_dir);
    if fs::metadata(&target_dir).is_err() {
        println!("Removed 0 files");
        return;
    }

    let files = index_files(&target_dir);
    let total_size: u64 = files
        .iter()
        .map(|file| fs::metadata(file).expect("Can't read file metadata").len())
        .sum();
    println!(
        "Removed {} files, {} total",
        files.len(),
        format_bytes(total_size)
    );
    fs::remove_dir_all(&target_dir).expect("Can't remove target directory");
}

fn subcommand_help() {
    println!(
        r"Usage: bob [SUBCOMMAND] [OPTIONS]

Options:
  -C <dir>         Change to directory <dir> before doing anything
  -r, --release    Build artifacts in release mode

Subcommands:
  clean            Remove build artifacts
  build            Build the project
  help             Print this help message
  run              Run the build artifact after building
  test             Run the unit tests
  version          Print the version number"
    );
}

fn subcommand_version() {
    println!("bob v{}", env!("CARGO_PKG_VERSION"));
}

// MARK: Main
pub(crate) struct Project {
    manifest_dir: String,
    manifest: Manifest,
    profile: Profile,
    is_test: bool,
    source_files: Vec<String>,
}

fn main() {
    let args = parse_args();

    if args.subcommand == Subcommand::Help {
        subcommand_help();
        return;
    }
    if args.subcommand == Subcommand::Version {
        subcommand_version();
        return;
    }

    // Read manifest
    let manifest: Manifest = basic_toml::from_str(
        &fs::read_to_string(format!("{}/bob.toml", args.manifest_dir)).unwrap_or_else(|err| {
            eprintln!("Can't read bob.toml file: {}", err);
            exit(1);
        }),
    )
    .unwrap_or_else(|err| {
        eprintln!("Can't parse bob.toml file: {}", err);
        exit(1);
    });

    // Clean build artifacts
    if args.subcommand == Subcommand::Clean {
        subcommand_clean(&args);
        return;
    }

    // Rebuild artifacts
    if args.subcommand == Subcommand::Rebuild {
        subcommand_clean(&args);
    }

    // Index source files
    let source_dir = format!("{}/src", args.manifest_dir);
    let source_files: Vec<String> = index_files(&source_dir)
        .into_iter()
        .map(|file| file.replace(&source_dir, "$source_dir"))
        .collect();

    // Generate ninja file
    let mut project = Project {
        manifest_dir: args.manifest_dir.clone(),
        manifest,
        profile: args.profile,
        is_test: args.subcommand == Subcommand::Test,
        source_files: source_files.clone(),
    };
    let generated_rules = generate_ninja_file(&mut project);

    // Run ninja
    let status = Command::new("ninja")
        .arg("-C")
        .arg(format!("{}/target", args.manifest_dir))
        .status()
        .expect("Failed to execute ninja");
    if !status.success() {
        exit(status.code().unwrap_or(1));
    }

    // Run build artifact
    if args.subcommand == Subcommand::Run {
        if generated_rules.contains(&Rule::Bundle) {
            rules::cx::run_bundle(&project);
        }
        if generated_rules.contains(&Rule::Ld) {
            rules::cx::run_ld(&project);
        }
        if generated_rules.contains(&Rule::AndroidApk) {
            rules::android::run_android_apk(&project);
        }
        if generated_rules.contains(&Rule::JavaJar) {
            rules::java::run_java_jar(&project);
        }
        if generated_rules.contains(&Rule::Java) {
            rules::java::run_java(&project);
        }
        eprintln!("No build artifact to run");
    }

    // Run unit tests
    if args.subcommand == Subcommand::Test {
        if generated_rules.contains(&Rule::Ld) {
            rules::cx::run_tests(&project);
        }
        eprintln!("No test artifact to run");
    }
}

fn generate_ninja_file(project: &mut Project) -> Vec<Rule> {
    // Generate ninja file
    let mut f = create_file_and_parent_dirs(format!("{}/target/build.ninja", project.manifest_dir))
        .expect("Can't create build.ninja file");

    // Project base variables
    _ = writeln!(f, "# This file is generated by bob, do not edit!");
    _ = writeln!(f, "name = {}", project.manifest.package.name);
    if let Some(identifier) = &project.manifest.package.identifier {
        _ = writeln!(f, "identifier = {}", identifier);
    }
    _ = writeln!(f, "version = {}", project.manifest.package.version);
    _ = writeln!(f, "profile = {}", project.profile);
    _ = writeln!(f, "manifest_dir = ..");
    _ = writeln!(f, "source_dir = $manifest_dir/src");
    _ = writeln!(f, "target_dir = $manifest_dir/target");
    _ = writeln!(f, "source_gen_dir = $target_dir/$profile/src-gen");

    // Generate rules
    let needed_rules = determine_needed_rules(project);
    for rule in &needed_rules {
        match rule {
            Rule::CxVars => rules::cx::generate_cx_vars(&mut f, project),
            Rule::C => rules::cx::generate_c(&mut f, project),
            Rule::Cpp => rules::cx::generate_cpp(&mut f, project),
            Rule::Objc => rules::cx::generate_objc(&mut f, project),
            Rule::Objcpp => rules::cx::generate_objcpp(&mut f, project),
            Rule::Ld => rules::cx::generate_ld(&mut f, project),
            Rule::Bundle => rules::cx::generate_bundle(&mut f, project),
            Rule::JavaVars => rules::java::generate_java_vars(&mut f, project),
            Rule::Java => rules::java::generate_java(&mut f, project),
            Rule::JavaJar => rules::java::generate_java_jar(&mut f, project),
            Rule::AndroidVars => rules::android::generate_android_vars(&mut f, project),
            Rule::AndroidRes => rules::android::generate_android_res(&mut f, project),
            Rule::AndroidDex => rules::android::generate_android_dex(&mut f, project),
            Rule::AndroidApk => rules::android::generate_android_apk(&mut f, project),
        };
    }
    needed_rules
}

fn determine_needed_rules(project: &Project) -> Vec<Rule> {
    let mut rules = Vec::new();

    // Variable rules
    for file in &project.source_files {
        if (file.ends_with(".c")
            || file.ends_with(".cpp")
            || file.ends_with(".m")
            || file.ends_with(".mm"))
            && !rules.contains(&Rule::CxVars)
        {
            rules.push(Rule::CxVars);
        }
        if file.ends_with(".java") && !rules.contains(&Rule::JavaVars) {
            rules.push(Rule::JavaVars);
        }
    }
    if fs::metadata(format!("{}/AndroidManifest.xml", project.manifest_dir)).is_ok() {
        rules.push(Rule::AndroidVars);
        rules.push(Rule::AndroidRes);
    }

    // Compile rules
    for file in &project.source_files {
        if file.ends_with(".c") && !rules.contains(&Rule::C) {
            rules.push(Rule::C);
        }
        if file.ends_with(".cpp") && !rules.contains(&Rule::Cpp) {
            rules.push(Rule::Cpp);
        }
        if file.ends_with(".m") && !rules.contains(&Rule::Objc) {
            rules.push(Rule::Objc);
        }
        if file.ends_with(".mm") && !rules.contains(&Rule::Objcpp) {
            rules.push(Rule::Objcpp);
        }
        if file.ends_with(".java") && !rules.contains(&Rule::Java) {
            rules.push(Rule::Java);
        }
    }

    // Link & package rules
    if rules.contains(&Rule::CxVars) {
        if project.is_test && !rules.contains(&Rule::C) {
            rules.push(Rule::C);
        }
        rules.push(Rule::Ld);
    }
    if project.manifest.package.metadata.bundle.is_some() {
        rules.push(Rule::Bundle);
    }
    if project.manifest.package.metadata.jar.is_some() {
        rules.push(Rule::JavaJar);
    }
    if rules.contains(&Rule::AndroidVars) {
        rules.push(Rule::AndroidDex);
        rules.push(Rule::AndroidApk);
    }
    rules
}
