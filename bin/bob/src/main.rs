/*
 * Copyright (c) 2025 Bastiaan van der Plaat
 *
 * SPDX-License-Identifier: MIT
 */

//! # Bassie's Obvious Builder (bob)
//!
//! A simple meta-build system for my projects, because I like the simplicity of Cargo. But meh it's just a ninja build file generator.

use std::fs::{self};
use std::io::Write;

use args::Profile;
use rules::Rule;
use utils::{create_file_with_dirs, format_bytes, index_files};

use crate::args::{parse_args, Args, SubCommand};
use crate::manifest::Manifest;

mod args;
mod manifest;
mod rules;
mod utils;

// MARK: Subcommands

fn subcommand_clean(args: &Args) {
    let target_dir = format!("{}/target", args.manifest_dir);
    if fs::metadata(&target_dir).is_err() {
        println!("Removed 0 files");
        return;
    }

    let files = index_files(&target_dir);
    let total_size: u64 = files
        .iter()
        .map(|file| fs::metadata(file).expect("Can't read file metadata").len())
        .sum();
    println!(
        "Removed {} files, {} total",
        files.len(),
        format_bytes(total_size)
    );
    fs::remove_dir_all(&target_dir).expect("Can't remove target directory");
}

fn subcommand_help() {
    println!("Usage: bob [SUBCOMMAND] [OPTIONS]");
    println!();
    println!("Options:");
    println!("  -C <dir>         Change to directory <dir> before doing anything");
    println!("  -r, --release    Build artifacts in release mode");
    println!();
    println!("Subcommands:");
    println!("  clean            Remove build artifacts");
    println!("  build            Build the project");
    println!("  help             Print this help message");
    println!("  run              Run the build artifact after building");
}

// MARK: Main
pub(crate) struct Project {
    manifest_dir: String,
    manifest: Manifest,
    profile: Profile,
    source_files: Vec<String>,
}

fn main() {
    let args = parse_args();

    if args.subcommand == SubCommand::Help {
        subcommand_help();
        return;
    }

    // Read manifest
    let manifest: Manifest = toml::from_str(
        &fs::read_to_string(format!("{}/bob.toml", args.manifest_dir))
            .expect("Can't read bob.toml file"),
    )
    .expect("Can't parse bob.toml file");

    // Clean build artifacts
    if args.subcommand == SubCommand::Clean {
        subcommand_clean(&args);
        return;
    }

    // Index source files
    let source_dir = format!("{}/src/", args.manifest_dir);
    let source_files: Vec<String> = index_files(&source_dir)
        .into_iter()
        .map(|file| {
            file.strip_prefix(&source_dir)
                .expect("Should be some")
                .to_string()
        })
        .collect();

    // Generate ninja file
    let project = Project {
        manifest_dir: args.manifest_dir.clone(),
        manifest,
        profile: args.profile,
        source_files: source_files.clone(),
    };
    let generated_rules = generate_ninja_file(&project);

    // Run ninja
    let status = std::process::Command::new("ninja")
        .arg("-C")
        .arg(format!("{}/target", args.manifest_dir))
        .status()
        .expect("Failed to execute ninja");
    if !status.success() {
        std::process::exit(status.code().unwrap_or(1));
    }

    // Run build artifact
    if args.subcommand == SubCommand::Run {
        if generated_rules.contains(&Rule::Bundle) {
            rules::cx::run_bundle(&project);
        }
        if generated_rules.contains(&Rule::Ld) {
            rules::cx::run_ld(&project);
        }

        if generated_rules.contains(&Rule::Jar) {
            rules::java::run_jar(&project);
        }
        if generated_rules.contains(&Rule::Java) {
            rules::java::run_java(&project);
        }
        panic!("No build artifact to run");
    }
}

fn generate_ninja_file(project: &Project) -> Vec<Rule> {
    // Generate ninja file
    let mut f = create_file_with_dirs(format!("{}/target/build.ninja", project.manifest_dir))
        .expect("Can't create build.ninja file");

    // Base variables
    _ = writeln!(f, "# This file is generated by bob, do not edit!");
    _ = writeln!(f, "name = {}", project.manifest.package.name);
    if let Some(identifier) = &project.manifest.package.identifier {
        _ = writeln!(f, "identifier = {}", identifier);
    }
    _ = writeln!(f, "version = {}", project.manifest.package.version);
    _ = writeln!(f, "profile = {}", project.profile);
    _ = writeln!(f, "manifest_dir = ..");
    _ = writeln!(f, "source_dir = $manifest_dir/src");
    _ = writeln!(f, "target_dir = $manifest_dir/target");

    // Determine needed rules
    let mut needed_rules = Vec::new();
    for file in &project.source_files {
        if (file.ends_with(".c")
            || file.ends_with(".cpp")
            || file.ends_with(".m")
            || file.ends_with(".mm"))
            && !needed_rules.contains(&Rule::CxCommon)
        {
            needed_rules.push(Rule::CxCommon);
        }
        if file.ends_with(".c") && !needed_rules.contains(&Rule::C) {
            needed_rules.push(Rule::C);
        }
        if file.ends_with(".cpp") && !needed_rules.contains(&Rule::Cpp) {
            needed_rules.push(Rule::Cpp);
        }
        if file.ends_with(".m") && !needed_rules.contains(&Rule::Objc) {
            needed_rules.push(Rule::Objc);
        }
        if file.ends_with(".mm") && !needed_rules.contains(&Rule::Objcpp) {
            needed_rules.push(Rule::Objcpp);
        }
        if file.ends_with(".java") && !needed_rules.contains(&Rule::Java) {
            needed_rules.push(Rule::Java);
        }
    }
    for file in &project.source_files {
        if (file.ends_with(".c")
            || file.ends_with(".cpp")
            || file.ends_with(".m")
            || file.ends_with(".mm"))
            && !needed_rules.contains(&Rule::Ld)
        {
            needed_rules.push(Rule::Ld);
        }
    }
    if let Some(metadata) = project.manifest.package.metadata.as_ref() {
        if metadata.jar.is_some() {
            needed_rules.push(Rule::Jar);
        }
        if metadata.bundle.is_some() {
            needed_rules.push(Rule::Bundle);
        }
    }

    // Generate rules
    for rule in &needed_rules {
        match rule {
            Rule::CxCommon => rules::cx::generate_cx_common(&mut f, project),
            Rule::C => rules::cx::generate_c(&mut f, project),
            Rule::Cpp => rules::cx::generate_cpp(&mut f, project),
            Rule::Objc => rules::cx::generate_objc(&mut f, project),
            Rule::Objcpp => rules::cx::generate_objcpp(&mut f, project),
            Rule::Ld => rules::cx::generate_ld(&mut f, project),
            Rule::Bundle => rules::cx::generate_bundle(&mut f, project),
            Rule::Java => rules::java::generate_java(&mut f, project),
            Rule::Jar => rules::java::generate_jar(&mut f, project),
        };
    }
    needed_rules
}
