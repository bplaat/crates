/*
 * Copyright (c) 2026 Bastiaan van der Plaat
 *
 * SPDX-License-Identifier: MIT
 */

//! A minimal replacement for the [zip](https://crates.io/crates/zip) crate

#![forbid(unsafe_code)]

use std::fmt;
use std::io::{self, Cursor, Read, Seek, SeekFrom};

// MARK: Entry metadata
struct CdEntry {
    name: String,
    compression: u16,
    compressed_size: u32,
    local_header_offset: u32,
}

// MARK: ZipFile
/// A file entry within a ZIP archive.
pub struct ZipFile {
    name: String,
    data: Cursor<Vec<u8>>,
}

impl ZipFile {
    /// Returns the name of the file.
    pub fn name(&self) -> &str {
        &self.name
    }
}

impl Read for ZipFile {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.data.read(buf)
    }
}

// MARK: ZipArchive
/// A ZIP archive.
pub struct ZipArchive<R> {
    reader: R,
    entries: Vec<CdEntry>,
}

fn read_u16_le(data: &[u8], offset: usize) -> u16 {
    u16::from_le_bytes(data[offset..offset + 2].try_into().expect("slice error"))
}

fn read_u32_le(data: &[u8], offset: usize) -> u32 {
    u32::from_le_bytes(data[offset..offset + 4].try_into().expect("slice error"))
}

impl<R: Read + Seek> ZipArchive<R> {
    /// Open a ZIP archive from a reader.
    pub fn new(mut reader: R) -> Result<Self, ZipError> {
        // Read all bytes for parsing
        let mut bytes = Vec::new();
        reader.read_to_end(&mut bytes)?;

        // Find End of Central Directory (EOCD) record by scanning backward for PK\x05\x06
        let eocd_offset = (0..bytes.len().saturating_sub(21))
            .rev()
            .find(|&i| bytes[i..i + 4] == [0x50, 0x4b, 0x05, 0x06])
            .ok_or(ZipError::InvalidZip("EOCD not found"))?;

        let cd_count = read_u16_le(&bytes, eocd_offset + 10) as usize;
        let cd_offset = read_u32_le(&bytes, eocd_offset + 16) as usize;

        // Parse central directory entries
        let mut entries = Vec::with_capacity(cd_count);
        let mut pos = cd_offset;
        for _ in 0..cd_count {
            if bytes.get(pos..pos + 4) != Some(&[0x50, 0x4b, 0x01, 0x02][..]) {
                return Err(ZipError::InvalidZip("invalid central directory signature"));
            }
            let compression = read_u16_le(&bytes, pos + 10);
            let compressed_size = read_u32_le(&bytes, pos + 20);
            let name_len = read_u16_le(&bytes, pos + 28) as usize;
            let extra_len = read_u16_le(&bytes, pos + 30) as usize;
            let comment_len = read_u16_le(&bytes, pos + 32) as usize;
            let local_header_offset = read_u32_le(&bytes, pos + 42);
            let name = String::from_utf8_lossy(&bytes[pos + 46..pos + 46 + name_len]).into_owned();
            pos += 46 + name_len + extra_len + comment_len;
            entries.push(CdEntry {
                name,
                compression,
                compressed_size,
                local_header_offset,
            });
        }

        // Seek back to start so the reader is in a consistent state
        reader.seek(SeekFrom::Start(0))?;

        Ok(ZipArchive { reader, entries })
    }

    /// Returns the number of entries in the archive.
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Returns `true` if the archive has no entries.
    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }

    /// Returns the entry at the given index.
    pub fn by_index(&mut self, index: usize) -> Result<ZipFile, ZipError> {
        let entry = self.entries.get(index).ok_or(ZipError::FileNotFound)?;
        let name = entry.name.clone();
        let compression = entry.compression;
        let compressed_size = entry.compressed_size as usize;
        let local_header_offset = entry.local_header_offset as u64;

        // Read local file header to find actual data start
        self.reader
            .seek(SeekFrom::Start(local_header_offset + 26))?;
        let mut lh_lens = [0u8; 4];
        self.reader.read_exact(&mut lh_lens)?;
        let lh_name_len = u16::from_le_bytes([lh_lens[0], lh_lens[1]]) as u64;
        let lh_extra_len = u16::from_le_bytes([lh_lens[2], lh_lens[3]]) as u64;
        self.reader.seek(SeekFrom::Start(
            local_header_offset + 30 + lh_name_len + lh_extra_len,
        ))?;

        // Read compressed data
        let mut compressed = vec![0u8; compressed_size];
        self.reader.read_exact(&mut compressed)?;

        let data = match compression {
            0 => compressed, // stored
            8 => miniz_oxide::inflate::decompress_to_vec(&compressed)
                .map_err(|_| ZipError::DecompressError)?,
            m => return Err(ZipError::UnsupportedCompressionMethod(m)),
        };

        Ok(ZipFile {
            name,
            data: Cursor::new(data),
        })
    }
}

// MARK: Error
/// ZIP error type.
#[derive(Debug)]
pub enum ZipError {
    /// An I/O error occurred.
    Io(io::Error),
    /// The ZIP file is invalid.
    InvalidZip(&'static str),
    /// The file number is out of range.
    FileNotFound,
    /// The compression method is unsupported.
    UnsupportedCompressionMethod(u16),
    /// Decompression failed.
    DecompressError,
}

impl fmt::Display for ZipError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ZipError::Io(e) => write!(f, "I/O error: {e}"),
            ZipError::InvalidZip(msg) => write!(f, "Invalid ZIP: {msg}"),
            ZipError::FileNotFound => write!(f, "File not found"),
            ZipError::UnsupportedCompressionMethod(m) => {
                write!(f, "Unsupported compression method: {m}")
            }
            ZipError::DecompressError => write!(f, "Decompression failed"),
        }
    }
}

impl std::error::Error for ZipError {}

impl From<io::Error> for ZipError {
    fn from(e: io::Error) -> Self {
        ZipError::Io(e)
    }
}

// MARK: Tests
#[cfg(test)]
mod tests {
    use super::*;

    // zip -0 stored.zip hello.txt (hello.txt = "hello world", stored)
    #[rustfmt::skip]
    const STORED_ZIP: &[u8] = &[0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x82, 0x61, 0x5c, 0x85, 0x11, 0x4a, 0x0d, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x09, 0x00, 0x1c, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x09, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x82, 0x61, 0x5c, 0x85, 0x11, 0x4a, 0x0d, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x09, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x05, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00];

    // zip -9 deflate.zip lorem.txt (lorem.txt = "the quick brown fox..." x50, deflated 97%)
    #[rustfmt::skip]
    const DEFLATE_ZIP: &[u8] = &[0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x04, 0x82, 0x61, 0x5c, 0x68, 0xac, 0x28, 0x64, 0x3f, 0x00, 0x00, 0x00, 0x98, 0x08, 0x00, 0x00, 0x09, 0x00, 0x1c, 0x00, 0x6c, 0x6f, 0x72, 0x65, 0x6d, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x09, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0xed, 0xca, 0x41, 0x02, 0x40, 0x20, 0x14, 0x04, 0xd0, 0x7d, 0xa7, 0x98, 0xab, 0x85, 0x28, 0xd2, 0x27, 0x3f, 0xca, 0xe9, 0x75, 0x09, 0xbb, 0x59, 0xbf, 0xa7, 0xde, 0xe1, 0x2c, 0x61, 0xdc, 0x30, 0x64, 0x79, 0x12, 0x66, 0xa9, 0x58, 0xcb, 0x7e, 0x5c, 0x90, 0xdb, 0x65, 0x68, 0xe7, 0x68, 0xdf, 0x86, 0x49, 0x16, 0xa3, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0x3f, 0xde, 0x0f, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x04, 0x82, 0x61, 0x5c, 0x68, 0xac, 0x28, 0x64, 0x3f, 0x00, 0x00, 0x00, 0x98, 0x08, 0x00, 0x00, 0x09, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x6f, 0x72, 0x65, 0x6d, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x05, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00];

    // zip -0 multi.zip hello.txt && zip -9 multi.zip lorem.txt (mixed stored + deflate)
    #[rustfmt::skip]
    const MULTI_ZIP: &[u8] = &[0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x82, 0x61, 0x5c, 0x85, 0x11, 0x4a, 0x0d, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x09, 0x00, 0x1c, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x09, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x04, 0x82, 0x61, 0x5c, 0x68, 0xac, 0x28, 0x64, 0x3f, 0x00, 0x00, 0x00, 0x98, 0x08, 0x00, 0x00, 0x09, 0x00, 0x1c, 0x00, 0x6c, 0x6f, 0x72, 0x65, 0x6d, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x09, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0xed, 0xca, 0x41, 0x02, 0x40, 0x20, 0x14, 0x04, 0xd0, 0x7d, 0xa7, 0x98, 0xab, 0x85, 0x28, 0xd2, 0x27, 0x3f, 0xca, 0xe9, 0x75, 0x09, 0xbb, 0x59, 0xbf, 0xa7, 0xde, 0xe1, 0x2c, 0x61, 0xdc, 0x30, 0x64, 0x79, 0x12, 0x66, 0xa9, 0x58, 0xcb, 0x7e, 0x5c, 0x90, 0xdb, 0x65, 0x68, 0xe7, 0x68, 0xdf, 0x86, 0x49, 0x16, 0xa3, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0x3f, 0xde, 0x0f, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x82, 0x61, 0x5c, 0x85, 0x11, 0x4a, 0x0d, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x09, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x05, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x04, 0x82, 0x61, 0x5c, 0x68, 0xac, 0x28, 0x64, 0x3f, 0x00, 0x00, 0x00, 0x98, 0x08, 0x00, 0x00, 0x09, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x4e, 0x00, 0x00, 0x00, 0x6c, 0x6f, 0x72, 0x65, 0x6d, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x05, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x9e, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00];

    // zip -9 keep.zip Keep/note.json Keep/empty.json (Keep/ subfolder, mixed compression)
    #[rustfmt::skip]
    const KEEP_ZIP: &[u8] = &[0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x04, 0x82, 0x61, 0x5c, 0xf3, 0xf9, 0xa3, 0x4c, 0x2d, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x1c, 0x00, 0x4b, 0x65, 0x65, 0x70, 0x2f, 0x6e, 0x6f, 0x74, 0x65, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x55, 0x54, 0x09, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0xab, 0x56, 0x2a, 0xc9, 0x2c, 0xc9, 0x49, 0x55, 0xb2, 0x52, 0x0a, 0x49, 0x2d, 0x2e, 0x51, 0xf0, 0xcb, 0x2f, 0x49, 0x55, 0xd2, 0x51, 0x2a, 0x49, 0xad, 0x28, 0x71, 0xce, 0xcf, 0x2b, 0x49, 0xcd, 0x2b, 0x01, 0xca, 0x24, 0xe5, 0xa7, 0x54, 0x2a, 0x80, 0x84, 0x94, 0x6a, 0x01, 0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x82, 0x61, 0x5c, 0xd8, 0x98, 0x9a, 0x64, 0x1d, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x1c, 0x00, 0x4b, 0x65, 0x65, 0x70, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x55, 0x54, 0x09, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x7b, 0x22, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x22, 0x3a, 0x22, 0x22, 0x2c, 0x22, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x22, 0x3a, 0x22, 0x22, 0x7d, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x14, 0x00, 0x02, 0x00, 0x08, 0x00, 0x04, 0x82, 0x61, 0x5c, 0xf3, 0xf9, 0xa3, 0x4c, 0x2d, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x65, 0x65, 0x70, 0x2f, 0x6e, 0x6f, 0x74, 0x65, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x55, 0x54, 0x05, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x01, 0x02, 0x1e, 0x03, 0x0a, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x82, 0x61, 0x5c, 0xd8, 0x98, 0x9a, 0x64, 0x1d, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x75, 0x00, 0x00, 0x00, 0x4b, 0x65, 0x65, 0x70, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x55, 0x54, 0x05, 0x00, 0x03, 0x38, 0x58, 0xa4, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0xa9, 0x00, 0x00, 0x00, 0xdb, 0x00, 0x00, 0x00, 0x00, 0x00];

    const LOREM: &str = "the quick brown fox jumps over the lazy dog\n";

    #[test]
    fn test_stored_single_file() {
        let mut archive = ZipArchive::new(Cursor::new(STORED_ZIP)).expect("open zip");
        assert_eq!(archive.len(), 1);
        let mut file = archive.by_index(0).expect("by_index");
        assert_eq!(file.name(), "hello.txt");
        let mut content = String::new();
        file.read_to_string(&mut content).expect("read");
        assert_eq!(content, "hello world");
    }

    #[test]
    fn test_deflate_single_file() {
        let mut archive = ZipArchive::new(Cursor::new(DEFLATE_ZIP)).expect("open zip");
        assert_eq!(archive.len(), 1);
        let mut file = archive.by_index(0).expect("by_index");
        assert_eq!(file.name(), "lorem.txt");
        let mut content = String::new();
        file.read_to_string(&mut content).expect("read");
        assert_eq!(content, LOREM.repeat(50));
    }

    #[test]
    fn test_multi_file_mixed_compression() {
        let mut archive = ZipArchive::new(Cursor::new(MULTI_ZIP)).expect("open zip");
        assert_eq!(archive.len(), 2);

        let mut file0 = archive.by_index(0).expect("by_index 0");
        assert_eq!(file0.name(), "hello.txt");
        let mut content0 = String::new();
        file0.read_to_string(&mut content0).expect("read 0");
        assert_eq!(content0, "hello world");

        let mut file1 = archive.by_index(1).expect("by_index 1");
        assert_eq!(file1.name(), "lorem.txt");
        let mut content1 = String::new();
        file1.read_to_string(&mut content1).expect("read 1");
        assert_eq!(content1, LOREM.repeat(50));
    }

    #[test]
    fn test_keep_subfolder() {
        let mut archive = ZipArchive::new(Cursor::new(KEEP_ZIP)).expect("open zip");
        assert_eq!(archive.len(), 2);

        let mut note = archive.by_index(0).expect("by_index 0");
        assert_eq!(note.name(), "Keep/note.json");
        let mut note_content = String::new();
        note.read_to_string(&mut note_content).expect("read note");
        assert_eq!(
            note_content,
            r#"{"title":"Test Note","textContent":"body text"}"#
        );

        let mut empty = archive.by_index(1).expect("by_index 1");
        assert_eq!(empty.name(), "Keep/empty.json");
        let mut empty_content = String::new();
        empty
            .read_to_string(&mut empty_content)
            .expect("read empty");
        assert_eq!(empty_content, r#"{"title":"","textContent":""}"#);
    }

    #[test]
    fn test_is_empty() {
        let archive = ZipArchive::new(Cursor::new(STORED_ZIP)).expect("open zip");
        assert!(!archive.is_empty());
    }

    #[test]
    fn test_out_of_range() {
        let mut archive = ZipArchive::new(Cursor::new(STORED_ZIP)).expect("open zip");
        assert!(matches!(archive.by_index(99), Err(ZipError::FileNotFound)));
    }

    #[test]
    fn test_invalid_zip() {
        assert!(matches!(
            ZipArchive::new(Cursor::new(b"not a zip file")),
            Err(ZipError::InvalidZip(_))
        ));
    }
}
