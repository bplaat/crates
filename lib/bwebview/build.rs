/*
 * Copyright (c) 2025 Bastiaan van der Plaat
 *
 * SPDX-License-Identifier: MIT
 */

//! A minimal windows webview2 example

fn main() {
    #[cfg(windows)]
    {
        // Generate webview2.rs bindings
        let winmd_path = std::path::PathBuf::from(
            std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set"),
        )
        .join("webview2")
        .join("Microsoft.Web.WebView2.Win32.winmd");
        let out_dir = std::path::PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR not set"));
        let bindings_path = out_dir.join("webview2_bindings.rs");
        windows::generate_webview2_bindings(&winmd_path, &bindings_path);

        // Link with the correct WebView2Loader library based on architecture
        let target = std::env::var("CARGO_CFG_TARGET_ARCH").expect("CARGO_CFG_TARGET_ARCH not set");
        let lib_dir = std::path::PathBuf::from(
            std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set"),
        )
        .join("webview2")
        .join(if target == "x86_64" {
            "x64"
        } else if target == "aarch64" {
            "arm64"
        } else if target == "x86" {
            "x86"
        } else {
            panic!("Unsupported architecture")
        });

        println!("cargo:rustc-link-search=native={}", lib_dir.display());
        let target_env =
            std::env::var("CARGO_CFG_TARGET_ENV").expect("CARGO_CFG_TARGET_ENV not set");
        if target_env == "msvc" {
            println!("cargo:rustc-link-lib=static=WebView2LoaderStatic");
        } else {
            println!("cargo:rustc-link-lib=dylib=WebView2Loader");

            // Copy WebView2Loader.dll to output directory for dynamic linking
            let out_dir =
                std::path::PathBuf::from(std::env::var("OUT_DIR").expect("OUT_DIR not set"));
            std::fs::copy(
                lib_dir.join("WebView2Loader.dll"),
                out_dir
                    .parent()
                    .expect("Should be some")
                    .parent()
                    .expect("Should be some")
                    .parent()
                    .expect("Should be some")
                    .join("WebView2Loader.dll"),
            )
            .expect("Failed to copy WebView2Loader.dll");
        }
    }
}

// MARK: Webview2 bindings generator
#[cfg(windows)]
mod windows {
    use std::io::Write;
    use std::path::Path;

    use windows_metadata::reader::{Index, TypeCategory, TypeDef};
    use windows_metadata::{HasAttributes, Type, Value};

    struct Interface {
        name: String,
        guid: Guid,
        methods: Vec<Method>,
    }

    struct Guid {
        data1: u32,
        data2: u16,
        data3: u16,
        data4: [u8; 8],
    }
    struct Method {
        name: String,
        return_type: String,
        arguments: Vec<(String, String)>,
    }

    pub(crate) fn generate_webview2_bindings(winmd_path: &Path, bindings_path: &Path) {
        let interfaces = index_winmd_file(winmd_path);

        // Write bindings to file
        let mut f = std::fs::File::create(bindings_path).expect("Failed to create bindings file");

        _ = write!(
            f,
            r#"
// This file is generated by openapi-generator, do not edit!

use std::ffi::c_void;

use super::win32::*;

#[cfg_attr(not(target_env = "msvc"), link(name = "WebView2Loader"))]
unsafe extern "system" {{
    pub(crate) fn CreateCoreWebView2EnvironmentWithOptions(
        browserExecutableFolder: *const w_char,
        userDataFolder: *const w_char,
        environmentOptions: *const c_void,
        creationCompletedHandler: *mut ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandler,
    ) -> HRESULT;
}}

#[cfg_attr(target_env = "msvc", link(name = "advapi32"))]
unsafe extern "C" {{}}

// FIXME: Also codegen enums
pub(crate) const COREWEBVIEW2_WEB_RESOURCE_CONTEXT_ALL: u32 = 0;

"#,
        );

        for interface in &interfaces {
            let name = &interface.name;

            let guid = format!(
                "pub const IID_{name}: GUID = GUID {{ data1: {}, data2: {}, data3: {}, data4: {:?} }};\n\n",
                interface.guid.data1,
                interface.guid.data2,
                interface.guid.data3,
                interface.guid.data4
            );

            let extra_fields = if name.ends_with("Handler") {
                "    pub user_data: *mut c_void,\n"
            } else {
                ""
            };

            let mut impls = String::new();
            let mut methods = String::new();
            for method in &interface.methods {
                let method_name = &method.name;
                let return_type = &method.return_type;
                let mut args = String::new();
                let mut arg_names = String::new();
                for (arg_name, arg_type) in &method.arguments {
                    args.push_str(&format!(", {}: {}", arg_name, arg_type));
                    arg_names.push_str(&format!(", {}", arg_name));
                }
                impls.push_str(&format!(
                    "    #[inline]
    pub(crate) unsafe fn {method_name}(&mut self{args}) -> {return_type} {{
        unsafe {{ ((*self.lpVtbl).{method_name})(self as *const _ as *mut _{arg_names}) }}
    }}
"
                ));
                methods.push_str(&format!(
                            "    pub {method_name}: unsafe extern \"system\" fn(This: *mut {name}{args}) -> {return_type},\n"
                        ));
            }

            _ = write!(
                f,
                r#"
// {name}
{guid}#[repr(C)]
pub(crate) struct {name} {{
    pub lpVtbl: *const {name}Vtbl,
{extra_fields}}}

impl {name} {{
    #[inline]
    pub(crate) unsafe fn QueryInterface(&mut self, riid: *const GUID, ppvObject: *mut *mut c_void) -> HRESULT {{
        unsafe {{ ((*self.lpVtbl).QueryInterface)(self as *const _ as *mut _, riid, ppvObject) }}
    }}
    #[inline]
    pub(crate) unsafe fn AddRef(&mut self) -> u32 {{
        unsafe {{ ((*self.lpVtbl).AddRef)(self as *const _ as *mut _) }}
    }}
    #[inline]
    pub(crate) unsafe fn Release(&mut self) -> u32 {{
        unsafe {{ ((*self.lpVtbl).Release)(self as *const _ as *mut _) }}
    }}
{impls}}}

#[repr(C)]
pub(crate) struct {name}Vtbl {{
    pub QueryInterface: unsafe extern "system" fn(This: *mut c_void, riid: *const GUID, ppvObject: *mut *mut c_void) -> HRESULT,
    pub AddRef: unsafe extern "system" fn(This: *mut c_void) -> u32,
    pub Release: unsafe extern "system" fn(This: *mut c_void) -> u32,
{methods}}}
"#
            );
        }
    }

    fn index_winmd_file(path: &Path) -> Vec<Interface> {
        let index = Index::read(path).expect("Failed to read winmd file");

        // class Apis

        let mut interfaces = Vec::new();
        let mut defs = index.all().collect::<Vec<_>>();
        defs.sort_by(|a, b| a.name().cmp(b.name()));
        for def in &defs {
            let name = def.name();
            if def.category() == TypeCategory::Interface {
                let mut methods = Vec::new();
                fn recurse_methods(
                    index: &Index,
                    def: &TypeDef,
                    interfaces: &mut Vec<Interface>,
                    methods: &mut Vec<Method>,
                ) {
                    if let Some(parent) = def.extends() {
                        let def = index
                            .get(parent.namespace(), parent.name())
                            .next()
                            .expect("Failed to find parent interface");
                        recurse_methods(index, &def, interfaces, methods);
                    }

                    let mut counter = 1;
                    for method in def.methods() {
                        let mut method_name = method.name().to_string();
                        let mut signature = method.signature(&[]);
                        let mut arg_types =
                            signature.types.iter().map(type_to_rust).collect::<Vec<_>>();

                        // // Very crude .NET abi to native COM abi conversion
                        // for arg in signature.types {
                        //     if let Type::Name(type_name) = &arg
                        //         && type_name.name.starts_with("TypedEventHandler")
                        //         && let Some(Type::Name(type_sender)) = type_name.generics.first()
                        //         && let Some(Type::Name(type_args)) = type_name.generics.get(1)
                        //         && interfaces.iter().all(|i| {
                        //             i.name
                        //                 != format!("I{}", type_args.name.replace("Args", "Handler"))
                        //         })
                        //     {
                        //         interfaces.push(Interface {
                        //             name: format!("I{}", type_args.name.replace("Args", "Handler")),
                        //             guid: None,
                        //             methods: vec![Method {
                        //                 name: "Invoke".to_string(),
                        //                 return_type: "HRESULT".to_string(),
                        //                 arguments: vec![
                        //                     (
                        //                         "sender".to_string(),
                        //                         format!("*mut I{}", type_sender.name),
                        //                     ),
                        //                     (
                        //                         "args".to_string(),
                        //                         format!("*mut I{}", type_args.name),
                        //                     ),
                        //                 ],
                        //             }],
                        //         });
                        //     }
                        // }
                        // if let Type::String | Type::Name(_) = &signature.return_type {
                        //     arg_types.push(format!(
                        //         "*mut {}",
                        //         type_to_rust(&signature.return_type).replace("*const ", "*mut ")
                        //     ));
                        //     signature.return_type = Type::I32;
                        // }
                        // if method_name.ends_with("Async") {
                        //     method_name = method_name.trim_end_matches("Async").to_string();
                        // }
                        // if methods.iter().any(|m| m.name == method_name) {
                        //     method_name = format!("{}_{}", method_name, counter);
                        //     counter += 1;
                        // }

                        methods.push(Method {
                            name: method_name,
                            return_type: type_to_rust(&signature.return_type),
                            arguments: arg_types
                                .iter()
                                .enumerate()
                                .map(|(i, ty)| (format!("arg{}", i), ty.clone()))
                                .collect(),
                        });
                    }
                }
                recurse_methods(&index, def, &mut interfaces, &mut methods);

                let guid = def
                    .find_attribute("GuidAttribute")
                    .expect("GuidAttribute not found");
                let mut values = guid.value().into_iter();
                let data1 = match values.next().expect("Should be some") {
                    (_, Value::U32(v)) => v,
                    _ => panic!("Unexpected value type for data1"),
                };
                let data2 = match values.next().expect("Should be some") {
                    (_, Value::U16(v)) => v,
                    _ => panic!("Unexpected value type for data2"),
                };
                let data3 = match values.next().expect("Should be some") {
                    (_, Value::U16(v)) => v,
                    _ => panic!("Unexpected value type for data3"),
                };
                let mut data4 = [0u8; 8];
                for (i, value) in values.enumerate() {
                    if let (_, Value::U8(v)) = value {
                        data4[i] = v;
                    } else {
                        panic!("Unexpected value type for data4");
                    }
                }

                interfaces.push(Interface {
                    name: name.to_string(),
                    guid: Guid {
                        data1,
                        data2,
                        data3,
                        data4,
                    },
                    methods,
                });
            }
        }
        interfaces
    }

    fn type_to_rust(ty: &Type) -> String {
        match ty {
            Type::Void => "c_void".to_string(),
            Type::Bool => "BOOL".to_string(),
            Type::Char => "u16".to_string(),
            Type::I8 => "i8".to_string(),
            Type::U8 => "u8".to_string(),
            Type::I16 => "i16".to_string(),
            Type::U16 => "u16".to_string(),
            Type::I32 => "i32".to_string(),
            Type::U32 => "u32".to_string(),
            Type::I64 => "i64".to_string(),
            Type::U64 => "u64".to_string(),
            Type::F32 => "f32".to_string(),
            Type::F64 => "f64".to_string(),
            Type::ISize => "isize".to_string(),
            Type::USize => "usize".to_string(),
            Type::String => "*const w_char".to_string(),
            Type::Object => "*mut c_void".to_string(),
            Type::AttributeEnum => "?".to_string(),
            Type::Name(type_name) => {
                if type_name.name.contains('`') {
                    if type_name.name.starts_with("TypedEventHandler") {
                        if let Some(Type::Name(type_args)) = type_name.generics.get(1) {
                            format!("*mut I{}", type_args.name.replace("Args", "Handler"))
                        } else {
                            "*mut c_void".to_string()
                        }
                    } else {
                        "*mut c_void".to_string()
                    }
                } else if type_name.name == "IRandomAccessStream" {
                    "*mut IStream".to_string()
                } else {
                    format!("*mut {}", type_name.name)
                }
            }
            Type::Array(_) => "?".to_string(),
            Type::ArrayRef(_) => "?".to_string(),
            Type::ConstRef(_) => "?".to_string(),
            Type::Generic(_) => "?".to_string(),
            Type::PtrMut(_, _) => "?".to_string(),
            Type::PtrConst(_, _) => "?".to_string(),
            Type::ArrayFixed(_, _) => "?".to_string(),
        }
    }
}
