/*
 * Copyright (c) 2024 Bastiaan van der Plaat
 *
 * SPDX-License-Identifier: MIT
 */

use indexmap::IndexMap;

use crate::openapi::{OpenApi, Schema};

trait ToCapitalize {
    fn to_capitalize(&self) -> String;
}
impl ToCapitalize for String {
    fn to_capitalize(&self) -> String {
        let mut c = self.chars();
        match c.next() {
            None => String::new(),
            Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
        }
    }
}

pub(crate) fn generator(spec: OpenApi, output: &str) {
    // Create output dir
    std::fs::create_dir_all(output).expect("Failed to create output directory");

    // Generate code for all schemas
    let mut schemas = IndexMap::new();
    for (name, schema) in spec.components.expect("No components").schemas {
        schema_generate_code(&mut schemas, name, &schema, false);
    }

    // Write .rs file
    let mut code = "// This file is generated by openapi-generator, do not edit!\n\n".to_string();
    for schema in schemas.values() {
        code.push_str(schema);
    }
    let path = format!(
        "{}/{}.rs",
        output,
        spec.info.title.to_lowercase().replace(" ", "_")
    );
    std::fs::write(&path, code).unwrap_or_else(|_| panic!("Failed to write: {}", path));
}

fn schema_generate_code(
    schemas: &mut IndexMap<String, String>,
    name: String,
    schema: &Schema,
    is_required: bool,
) -> String {
    if let Some(r#enum) = &schema.r#enum {
        let name = name.to_capitalize();
        let mut code = String::new();
        code.push_str(
            "#[derive(Copy, Clone, Eq, PartialEq, serde::Deserialize, serde::Serialize)]\n",
        );
        code.push_str(&format!("pub(crate) enum {} {{\n", name));
        for variant in r#enum {
            code.push_str(&format!(
                "    #[serde(rename = \"{}\")]\n    {},\n",
                variant,
                variant.to_capitalize()
            ));
        }
        code.push_str("}\n\n");
        schemas.insert(name.clone(), code);
        return name;
    }

    if let Some(additional_properties) = &schema.additional_properties {
        let field_type = schema_generate_code(schemas, name.clone(), additional_properties, true);
        let code = format!(
            "#[derive(Clone, serde::Deserialize, serde::Serialize)]\npub(crate) struct {}(std::collections::HashMap<String, {}>);\n\n",
            name,
            field_type
        );
        schemas.insert(name.clone(), code);
        return name;
    }

    if schema.r#type == "object" {
        let mut code = String::new();
        code.push_str(&format!(
            "#[derive(Clone, serde::Deserialize, serde::Serialize)]\npub(crate) struct {} {{\n",
            name
        ));
        if let Some(properties) = &schema.properties {
            for (prop_name, prop_schema) in properties {
                let prop_type = schema_generate_code(
                    schemas,
                    prop_name.to_string(),
                    prop_schema,
                    schema
                        .required
                        .as_ref()
                        .map(|required| required.contains(prop_name))
                        .unwrap_or_else(|| false),
                );
                code.push_str(&format!("    pub {}: {},\n", prop_name, prop_type));
            }
        }
        code.push_str("}\n\n");
        schemas.insert(name.clone(), code);
        return name;
    }

    let r#type = match schema.r#type.as_str() {
        "string" => {
            if schema.r#enum.is_some() {
                return schema_generate_code(schemas, name, schema, true);
            }
            match schema.format.as_deref() {
                Some("uuid") => "uuid::Uuid",
                Some("date-time") => "chrono::DateTime<chrono::Utc>",
                _ => "String",
            }
        }
        .to_string(),
        "number" => match schema.format.as_deref() {
            Some("float") => "f32",
            Some("double") => "f64",
            _ => "f64",
        }
        .to_string(),
        "integer" => match schema.format.as_deref() {
            Some("int32") => "i32",
            Some("int64") => "i64",
            _ => "i64",
        }
        .to_string(),
        "boolean" => "bool".to_string(),
        "array" => {
            let items = schema.items.as_ref().expect("No items");
            let item_type = schema_generate_code(schemas, "item".to_string(), items, true);
            format!("Vec<{}>", item_type)
        }
        _ => panic!("Unsupported type"),
    };
    if !is_required {
        format!("Option<{}>", r#type)
    } else {
        r#type
    }
}
