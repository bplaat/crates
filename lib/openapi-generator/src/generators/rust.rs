/*
 * Copyright (c) 2024-2025 Bastiaan van der Plaat
 *
 * SPDX-License-Identifier: MIT
 */

use std::fmt::Write;
use std::path::Path;

use indexmap::IndexMap;

use crate::openapi::Schema;
use crate::utils::ToCase;

pub(crate) fn generate_schemas(schemas: IndexMap<String, Schema>, output_path: &Path) {
    // Generate code for schemas
    let mut code_schemas = IndexMap::new();
    for (name, schema) in schemas {
        schema_generate_code(&mut code_schemas, name.clone(), &schema);
    }

    // Write .rs file
    let mut code = "// This file is generated by openapi-generator, do not edit!\n\n".to_string();
    for code_schema in code_schemas.values() {
        code.push_str(code_schema);
    }
    std::fs::write(output_path, code)
        .unwrap_or_else(|_| panic!("Failed to write: {}", output_path.display()));
}

fn schema_generate_code(
    code_schemas: &mut IndexMap<String, String>,
    name: String,
    schema: &Schema,
) -> String {
    let name = name.to_student_case();

    if let Some(r#ref) = &schema.r#ref {
        let ref_parts: Vec<&str> = r#ref.split('/').collect();
        return ref_parts.last().expect("Invalid ref").to_string();
    }

    if let Some(r#enum) = &schema.r#enum {
        let mut code = format!(
            "#[derive(Copy, Clone, Eq, PartialEq, serde::Deserialize, serde::Serialize)]\npub(crate) enum {name} {{\n"
        );
        for variant in r#enum {
            _ = writeln!(
                code,
                "    #[serde(rename = \"{}\")]\n    {},",
                variant.to_snake_case(),
                variant.to_student_case()
            );
        }
        code.push_str("}\n\n");
        code_schemas.insert(name.clone(), code);
        return name;
    }

    if let Some(additional_properties) = &schema.additional_properties {
        let field_type = schema_generate_code(code_schemas, name.clone(), additional_properties);
        let code = format!(
            "#[derive(Clone, serde::Deserialize, serde::Serialize)]\npub(crate) struct {name}(pub std::collections::HashMap<String, {field_type}>);\n\n",
        );
        code_schemas.insert(name.clone(), code);
        return name;
    }

    let r#type = schema.r#type.as_ref().expect("Schema should have type");
    if r#type == "object" {
        let mut code = format!(
            "#[derive(Clone, serde::Deserialize, serde::Serialize)]\npub(crate) struct {name} {{\n",
        );
        if let Some(properties) = &schema.properties {
            for (prop_name, prop_schema) in properties {
                let is_optional = schema
                    .required
                    .as_ref()
                    .map(|required| !required.contains(prop_name))
                    .unwrap_or_else(|| true);
                let mut prop_type =
                    schema_generate_code(code_schemas, prop_name.clone(), prop_schema);
                if prop_type == name {
                    prop_type = format!("Box<{prop_type}>");
                }
                let prop_name = prop_name.replace("type", "r#type");
                let field_name = prop_name.to_snake_case();
                if is_optional {
                    if prop_name != field_name {
                        _ = writeln!(
                            code,
                            "    #[serde(rename = \"{prop_name}\", skip_serializing_if = \"Option::is_none\")]"
                        );
                    } else {
                        code.push_str("    #[serde(skip_serializing_if = \"Option::is_none\")]\n");
                    }
                    _ = writeln!(code, "    pub {field_name}: Option<{prop_type}>,");
                } else {
                    if prop_name != field_name {
                        _ = writeln!(code, "    #[serde(rename = \"{prop_name}\")]");
                    }
                    _ = writeln!(code, "    pub {field_name}: {prop_type},");
                }
            }
        }
        code.push_str("}\n\n");
        code_schemas.insert(name.clone(), code);
        return name;
    }

    match r#type.as_str() {
        "string" => {
            if schema.r#enum.is_some() {
                return schema_generate_code(code_schemas, name, schema);
            }
            match schema.format.as_deref() {
                Some("uuid") => "uuid::Uuid",
                Some("date-time") => "chrono::DateTime<chrono::Utc>",
                _ => "String",
            }
            .to_string()
        }
        "number" => match schema.format.as_deref() {
            Some("float") => "f32",
            _ => "f64",
        }
        .to_string(),
        "integer" => match schema.format.as_deref() {
            Some("int32") => "i32",
            _ => "i64",
        }
        .to_string(),
        "boolean" => "bool".to_string(),
        "array" => {
            let items = schema.items.as_ref().expect("No items");
            let item_type = schema_generate_code(code_schemas, "item".to_string(), items);
            format!("Vec<{item_type}>")
        }
        _ => panic!("Unsupported type"),
    }
}
